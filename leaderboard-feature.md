# CC Leaderboard Feature Plan

## Overview
This document outlines the plan for implementing a leaderboard feature for the Claude Code usage tracking Mac app. The feature will allow users to join a global leaderboard by choosing a username and uploading their daily usage data to a Cloudflare Workers backend with D1 database storage.

## Architecture Overview

### Data Flow
1. User clicks "Join Leaderboard" in Mac app
2. User enters a username (one-time setup)
3. App periodically uploads daily usage data to backend
4. Backend stores data in Cloudflare D1 database
5. Users can view global leaderboard rankings

### Components
- **Mac App**: UI for joining leaderboard, data upload logic
- **Backend API**: Hono.js on Cloudflare Workers
- **Database**: Cloudflare D1 (SQLite)

## Backend Implementation Plan

### 1. Database Schema (Cloudflare D1)

```sql
-- Users table (one per device)
CREATE TABLE users (
    username TEXT PRIMARY KEY,
    device_id TEXT UNIQUE NOT NULL, -- Unique device identifier (UUID)
    created_at TEXT DEFAULT (datetime('now')),
    last_upload_at TEXT,
    last_sync_date TEXT, -- Last date this user synced data
    total_requests INTEGER DEFAULT 0,
    total_input_tokens INTEGER DEFAULT 0,
    total_output_tokens INTEGER DEFAULT 0,
    total_cost REAL DEFAULT 0
);

-- Daily usage entries
CREATE TABLE daily_usage (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT NOT NULL,
    date TEXT NOT NULL,
    total_requests INTEGER NOT NULL,
    total_input_tokens INTEGER NOT NULL,
    total_output_tokens INTEGER NOT NULL,
    total_cost REAL NOT NULL,
    created_at TEXT DEFAULT (datetime('now')),
    updated_at TEXT DEFAULT (datetime('now')),
    UNIQUE(username, date),
    FOREIGN KEY (username) REFERENCES users(username)
);

-- Indexes for performance
CREATE INDEX idx_daily_usage_username ON daily_usage(username);
CREATE INDEX idx_daily_usage_date ON daily_usage(date);
CREATE INDEX idx_users_total_requests ON users(total_requests DESC);
CREATE INDEX idx_users_total_cost ON users(total_cost DESC);
CREATE INDEX idx_users_total_tokens ON users(total_input_tokens + total_output_tokens DESC);
```

### 2. API Endpoints

#### POST /api/v1/users/register
Register a new username with device ID (one username per device)
```typescript
interface RegisterRequest {
  username: string; // 3-30 chars, alphanumeric + underscore
  deviceId: string; // UUID generated by Mac app
}

interface RegisterResponse {
  success: boolean;
  username: string;
  created: boolean; // false if already exists
  error?: string;   // e.g., "Username already taken" or "Device already registered"
}
```

#### POST /api/v1/usage/upload
Upload daily usage data (bulk upload support)
```typescript
interface UploadRequest {
  username: string;
  dailyUsage: {
    date: string; // YYYY-MM-DD
    totalRequests: number;
    totalInputTokens: number;
    totalOutputTokens: number;
    totalCost: number;
  }[];
}

interface UploadResponse {
  success: boolean;
  uploaded: number; // count of new entries
  skipped: number;  // count of duplicate entries
  errors?: string[];
}
```

#### GET /api/v1/leaderboard
Get leaderboard rankings
```typescript
interface LeaderboardRequest {
  metric: 'requests' | 'tokens' | 'cost'; // default: 'requests'
  period: 'all' | 'month' | 'week';       // default: 'all'
  limit?: number;                         // default: 100, max: 500
  offset?: number;                        // for pagination
}

interface LeaderboardResponse {
  leaderboard: {
    rank: number;
    username: string;
    totalRequests: number;
    totalTokens: number;
    totalCost: number;
    lastActive: string; // ISO date
  }[];
  total: number; // total users
  period: string;
  metric: string;
}
```

#### GET /api/v1/users/:username/sync-status
Get sync status for efficient data upload
```typescript
interface SyncStatusResponse {
  username: string;
  lastSyncDate: string | null;    // Last date data was uploaded
  lastUploadTime: string | null;  // ISO timestamp of last upload
  totalDaysUploaded: number;
}
```

#### GET /api/v1/users/:username/stats
Get detailed stats for a specific user
```typescript
interface UserStatsResponse {
  username: string;
  globalRank: {
    byRequests: number;
    byTokens: number;
    byCost: number;
  };
  totals: {
    requests: number;
    inputTokens: number;
    outputTokens: number;
    cost: number;
  };
  recentActivity: {
    date: string;
    requests: number;
    cost: number;
  }[]; // last 30 days
}
```

### 3. Backend Implementation Details

#### Security & Rate Limiting
- Rate limit: 100 requests per minute per IP
- Username validation: 3-30 chars, alphanumeric + underscore only
- No sensitive data stored (no API keys, personal info)
- CORS configured for Mac app bundle ID

#### Data Validation
- Verify date formats (YYYY-MM-DD)
- Validate numeric values are non-negative
- Check for reasonable limits (e.g., max 10,000 requests per day)
- Prevent future dates

#### Duplicate Prevention & Update Logic
- Use UNIQUE constraint on (username, date) for idempotent uploads
- Return skipped count in response
- Use UPSERT logic for handling same-day updates:

```sql
INSERT INTO daily_usage (username, date, total_requests, total_input_tokens, total_output_tokens, total_cost)
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(username, date) DO UPDATE SET
  total_requests = excluded.total_requests,
  total_input_tokens = excluded.total_input_tokens,
  total_output_tokens = excluded.total_output_tokens,
  total_cost = excluded.total_cost,
  updated_at = datetime('now')
WHERE excluded.total_requests >= daily_usage.total_requests;
-- Only update if new data has same or more requests (prevents data loss)
```

## Mac App Implementation Plan

### 1. New UI Components

#### Leaderboard Tab
- New tab in main window alongside existing daily usage view
- Shows "Join Leaderboard" button if not joined
- Shows leaderboard table if joined

#### Join Leaderboard Flow
1. Modal dialog with username input field
2. Username validation (real-time)
3. "Check Availability" button
4. Terms of service checkbox (data is public, etc.)
5. "Join" button

#### Leaderboard View
- Segmented control: All Time | This Month | This Week
- Metric selector: Total Requests | Total Tokens | Total Cost
- Table with columns: Rank, Username, Value, Last Active
- User's own row highlighted
- Pull to refresh functionality

### 2. Data Upload Logic

#### Upload Service
```swift
class LeaderboardService: ObservableObject {
    @Published var isJoined: Bool = false
    @Published var username: String?
    @Published var deviceId: String = getOrCreateDeviceId()
    
    // Check if user has joined (stored in UserDefaults)
    func checkJoinedStatus() -> Bool
    
    // Register username with backend (includes device ID)
    func joinLeaderboard(username: String) async throws
    
    // Get sync status from backend
    func getSyncStatus() async throws -> SyncStatus
    
    // Upload usage data with hybrid sync strategy
    func syncUsageData(dailyUsage: [DailyUsage]) async throws
    
    // Fetch leaderboard data
    func fetchLeaderboard(metric: String, period: String) async throws -> [LeaderboardEntry]
}
```

#### Upload Strategy (Hybrid Approach)
1. **Initial Upload**: When joining, upload all available historical data
2. **Sync Check**: On app launch and periodically:
   - Call `/api/v1/users/:username/sync-status` to get last sync info
   - Compare with local data to determine what needs uploading
3. **Incremental Upload**:
   - Upload all dates > lastSyncDate from backend
   - For today's date: always upload if data exists (handles intra-day updates)
4. **Local Tracking**: Store in UserDefaults:
   - `leaderboardDeviceId`: UUID for this device
   - `leaderboardUsername`: Current username
   - `lastLocalSyncDate`: Last date we attempted to sync
5. **Conflict Resolution**: Backend UPSERT ensures latest data wins
6. **Background Upload**: Use URLSession background tasks for reliability

### 3. Local Storage Updates

#### UserDefaults Keys
- `leaderboardDeviceId`: String (UUID, generated once)
- `leaderboardUsername`: String?
- `leaderboardJoinedDate`: Date?
- `lastLocalSyncDate`: Date? // Last date we attempted sync
- `pendingUploads`: [String] // dates with pending uploads

#### Device ID Generation
```swift
func getOrCreateDeviceId() -> String {
    if let deviceId = UserDefaults.standard.string(forKey: "leaderboardDeviceId") {
        return deviceId
    } else {
        let newDeviceId = UUID().uuidString
        UserDefaults.standard.set(newDeviceId, forKey: "leaderboardDeviceId")
        return newDeviceId
    }
}
```

#### Upload Queue
- Store failed uploads locally
- Retry on next app launch
- Clear after successful upload

### 4. Privacy & User Control

#### Settings
- Toggle: "Participate in Leaderboard" (can disable anytime)
- Button: "Delete My Leaderboard Data" (removes from server)
- Info: What data is shared (only aggregated stats, no raw prompts)

#### Data Shared
- Daily request counts
- Token usage by model
- Costs (calculated from tokens)
- NO prompt content or project names

## Implementation Phases

### Phase 1: Backend Setup (Week 1)
1. Configure D1 database in Cloudflare
2. Create database schema
3. Implement user registration endpoint
4. Implement usage upload endpoint
5. Add basic rate limiting

### Phase 2: Mac App Integration (Week 2)
1. Add Leaderboard tab UI
2. Implement join leaderboard flow
3. Add LeaderboardService
4. Implement data upload logic
5. Handle offline/retry scenarios

### Phase 3: Leaderboard Display (Week 3)
1. Implement leaderboard API endpoint
2. Add leaderboard UI in Mac app
3. Add filtering and sorting options
4. Implement user stats endpoint
5. Add detailed stats view

### Phase 4: Polish & Launch (Week 4)
1. Add data export feature
2. Implement deletion flow
3. Performance optimization
4. Error handling improvements
5. Documentation

## Technical Considerations

### Performance
- Batch uploads to reduce API calls
- Cache leaderboard data locally (5-minute TTL)
- Use database indexes for fast queries
- Implement pagination for large datasets

### Reliability
- Graceful degradation if backend unavailable
- Queue uploads for retry
- Validate data before upload
- Handle clock skew issues

### Scalability
- D1 can handle millions of rows
- Use Cloudflare's global network
- Implement caching at edge
- Consider aggregation tables for common queries

## Security Considerations

1. **No Authentication**: Simple username-based system
2. **Public Data**: All leaderboard data is public
3. **Rate Limiting**: Prevent abuse
4. **Input Validation**: Strict validation on all inputs
5. **No PII**: Don't collect personal information

## Future Enhancements

1. **Achievements/Badges**: Milestone rewards
2. **Team Leaderboards**: Organization-based boards
3. **Historical Charts**: Usage trends over time
4. **Model-Specific Leaderboards**: Rankings by model usage
5. **Export API**: Allow data export in various formats
6. **Social Features**: Follow other users, compare stats